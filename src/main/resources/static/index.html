<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Title</title>

    <style type="text/css">
        text {
            font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
        }
        svg {
            width: 100%;
        }
        .link {
            fill: none;
            stroke: #ddd;
            stroke-width: 1px;
        }
        .node {
            stroke: #000;
            stroke-width: 1px;
        }
    </style>

    <script src="js/d3.min.js"></script>
    <script src="js/jquery-3.3.1.min.js"></script>
    <script src="js/d3-selection-multi.v1.js"></script>
    
</head>

<body>
        <script type="text/javascript">

            // dimensions
            var width = 1000;
            var height = 1000;
    
            var margin = {
                top: 50,
                bottom: 50,
                left: 50,
                right: 50,
            }
    
            // create an svg to draw in
            var svg = d3.select("body")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append('g')
                .attr('transform', 'translate(' + margin.top + ',' + margin.left + ')');
            
            svg.append('defs').append('marker')
                .attrs({'id':'arrowhead',
                    'viewBox':'-0 -5 10 10',
                    'refX':13,
                    'refY':0,
                    'orient':'auto',
                    'markerWidth':13,
                    'markerHeight':13,
                    'xoverflow':'visible'})
                .append('svg:path')
                .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                .attr('fill', '#999')
                .style('stroke','none');
    
            width = width - margin.left - margin.right;
            height = height - margin.top - margin.bottom;
    
            var simulation = d3.forceSimulation()
                // pull nodes together based on the links between them
                .force("link", d3.forceLink().id(function(d) {
                    return d.id;
                })
                .distance(800)
                .strength(0.025))
                // push nodes apart to space them out
                .force("charge", d3.forceManyBody().strength(-200))
                // add some collision detection so they don't overlap
                .force("collide", d3.forceCollide().radius(12))
                // and draw them around the centre of the space
                .force("center", d3.forceCenter(width / 2, height / 2));
    
            // load the graph
            $.ajax({ 
                type: "GET",
                url: 'list-entities'
            }).done(function (resp) {
                
                // set the nodes
                var nodes = resp.nodes;
                // links between nodes
                var links = resp.links;
                
                // add the curved links to our graphic
                var link = svg.selectAll(".link")
                    .data(links)
                    .enter()
                    .append("path")
                    .attr("class", "link")
                    .attr('stroke', function(d){
                        return "#ddd";
                    })
                    .attr('marker-end','url(#arrowhead)');

                var edgepaths = svg.selectAll(".edgepath")
                    .data(links)
                    .enter()
                    .append('path')
                    .attrs({
                        'class': 'edgepath',
                        'fill-opacity': 0,
                        'stroke-opacity': 0,
                        'id': function (d, i) {return 'edgepath' + i}
                    })
                    .style("pointer-events", "none");

                var edgelabels = svg.selectAll(".edgelabel")
                    .data(links)
                    .enter()
                    .append('text')
                    .style("pointer-events", "none")
                    .attrs({
                        'class': 'edgelabel',
                        'id': function (d, i) {return 'edgelabel' + i},
                        'font-size': 10,
                        'fill': '#aaa'
                    });

                edgelabels.append('textPath')
                    .attr('xlink:href', function (d, i) {return '#edgepath' + i})
                    .style("text-anchor", "middle")
                    .style("pointer-events", "none")
                    .attr("startOffset", "50%")
                    .text(function (d) {return d.type});
    
                // add the nodes to the graphic
                var node = svg.selectAll(".node")
                    .data(nodes)
                    .enter().append("g")
    
                // a circle to represent the node
                node.append("circle")
                    .attr("class", "node")
                    .attr("r", 8)
                    .attr("fill", function(d) {
                        //return d.colour;
                        return "#008142";
                    })
                    .on("mouseover", mouseOver(.2))
                    .on("mouseout", mouseOut);
    
                // hover text for the node
                node.append("title")
                    .text(function(d) {
                        return d.label;
                    });
    
                // add a label to each node
                node.append("text")
                    .attr("dx", 12)
                    .attr("dy", ".35em")
                    .text(function(d) {
                        return d.name;
                    })
                    .style("stroke", "black")
                    .style("stroke-width", 0.5)
                    .style("fill", function(d) {
                        //return d.colour;
                        return "#008142";
                    });
    
                // add the nodes to the simulation and
                // tell it what to do on each tick
                simulation
                    .nodes(nodes)
                    .on("tick", ticked);
    
                // add the links to the simulation
                simulation
                    .force("link")
                    .links(links);
    
                // on each tick, update node and link positions
                function ticked() {
                    
                    link.attr("d", positionLink);
                    node.attr("transform", positionNode);

                    edgepaths.attr('d', function (d) {
                        return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
                    });

                    edgelabels.attr('transform', function (d) {
                        if (d.target.x < d.source.x) {
                            var bbox = this.getBBox();

                            rx = bbox.x + bbox.width / 2;
                            ry = bbox.y + bbox.height / 2;
                            return 'rotate(180 ' + rx + ' ' + ry + ')';
                        }
                        else {
                            return 'rotate(0)';
                        }
                    });

                }
    
                // links are drawn as curved paths between nodes,
                // through the intermediate nodes
                function positionLink(d) {
                    var offset = 30;
    
                    var midpoint_x = (d.source.x + d.target.x) / 2;
                    var midpoint_y = (d.source.y + d.target.y) / 2;
    
                    var dx = (d.target.x - d.source.x);
                    var dy = (d.target.y - d.source.y);
    
                    var normalise = Math.sqrt((dx * dx) + (dy * dy));
    
                    var offSetX = midpoint_x + offset*(dy/normalise);
                    var offSetY = midpoint_y - offset*(dx/normalise);
    
                    return "M" + d.source.x + "," + d.source.y +
                        "S" + offSetX + "," + offSetY +
                        " " + d.target.x + "," + d.target.y;
                }
    
                // move the node based on forces calculations
                function positionNode(d) {
                    // keep the node within the boundaries of the svg
                    if (d.x < 0) {
                        d.x = 0
                    };
                    if (d.y < 0) {
                        d.y = 0
                    };
                    if (d.x > width) {
                        d.x = width
                    };
                    if (d.y > height) {
                        d.y = height
                    };
                    return "translate(" + d.x + "," + d.y + ")";
                }
    
                // build a dictionary of nodes that are linked
                var linkedByIndex = {};
                links.forEach(function(d) {
                    linkedByIndex[d.source.index + "," + d.target.index] = 1;
                });
    
                // check the dictionary to see if nodes are linked
                function isConnected(a, b) {
                    return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
                }
    
                // fade nodes on hover
                function mouseOver(opacity) {
                    return function(d) {
                        // check all other nodes to see if they're connected
                        // to this one. if so, keep the opacity at 1, otherwise
                        // fade
                        node.style("stroke-opacity", function(o) {
                            thisOpacity = isConnected(d, o) ? 1 : opacity;
                            return thisOpacity;
                        });
                        node.style("fill-opacity", function(o) {
                            thisOpacity = isConnected(d, o) ? 1 : opacity;
                            return thisOpacity;
                        });
                        // also style link accordingly
                        link.style("stroke-opacity", function(o) {
                            return o.source === d || o.target === d ? 1 : opacity;
                        });
                        link.style("stroke", function(o){
                            return o.source === d || o.target === d ? o.source.colour : "#ddd";
                        });
                    };
                }
    
                function mouseOut() {
                    node.style("stroke-opacity", 1);
                    node.style("fill-opacity", 1);
                    link.style("stroke-opacity", 1);
                    link.style("stroke", "#ddd");
                }
    
            });
    
        </script>

</body>

</html>